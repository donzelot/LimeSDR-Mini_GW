-- generated by pyha 0.0.11
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataValid_0.all;
    use work.DataValid_1.all;
    use work.DataValid_2.all;
    use work.DataValid_3.all;
    use work.DataValid_4.all;
    use work.ShiftRegister_5.all;
    use work.DownCounter_6.all;
    use work.MovingAverage_7.all;
    use work.ShiftRegister_8.all;
    use work.MovingAverage_9.all;
    use work.ShiftRegister_10.all;
    use work.DCRemoval_11.all;

-- Window function
-- ---------------
-- Window function determines the frequency response of the FFT bins.
-- Args:
-- window_length: Same as the FFT transform size.
-- window (str): Name of the windowing function (imported from Scipy).
-- coefficient_bits: Coefficients are stored as constants in LUTS.
-- You will probably want to use the 8-bit 'hamming' window if the 'window_length' gets large.
package Windower_12 is
    type self_t is record
        window_pure: Typedefs.sfixed0downto_17_list_t(0 to 511);
        output: DataValid_3.self_t;
        index_counter: integer;
        coef: sfixed(0 downto -10);
    end record;
    type Windower_12_self_t_list_t is array (natural range <>) of Windower_12.self_t;

    type self_t_const is record
        WINDOW_LENGTH: integer;
        WINDOW: Typedefs.sfixed0downto_10_list_t(0 to 511);
        output: DataValid_3.self_t_const;
    end record;
    type Windower_12_self_t_const_list_t_const is array (natural range <>) of Windower_12.self_t_const;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; input: DataValid_3.self_t; ret_0:out DataValid_3.self_t);
    function Windower(window_pure: Typedefs.sfixed0downto_17_list_t(0 to 511); output: DataValid_3.self_t; index_counter: integer; coef: sfixed(0 downto -10)) return self_t;
end package;

package body Windower_12 is
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; input: DataValid_3.self_t; ret_0:out DataValid_3.self_t) is
    -- Args:
    -- input (DataValid): -1.0 ... 1.0 range, up to 18 bits
    -- Returns:
    -- DataValid: Result rounded to 18 bits(-1.0 ... 1.0 range). Overflow impossible.

    begin
        if not input.valid then
            ret_0 := DataValid(self.output.data, valid=>False);
            return;

        end if;
        self_next.index_counter := (self.index_counter + 1) mod self_const.WINDOW_LENGTH;
        self_next.coef := resize(self_const.WINDOW(self.index_counter), 0, -10, fixed_saturate, fixed_round);

        self_next.output.data := resize(input.data * self.coef, 0, -17, fixed_wrap, fixed_round);
        self_next.output.valid := input.valid;
        ret_0 := self.output;
        return;
    end procedure;

    function Windower(window_pure: Typedefs.sfixed0downto_17_list_t(0 to 511); output: DataValid_3.self_t; index_counter: integer; coef: sfixed(0 downto -10)) return self_t is
        -- constructor
        variable self: self_t;
    begin
        self.window_pure := window_pure;
        self.output := output;
        self.index_counter := index_counter;
        self.coef := coef;
        return self;
    end function;
end package body;
