-- generated by pyha 0.0.10
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataValid_41.all;
    use work.DataValid_40.all;
    use work.DataValid_39.all;
    use work.DataValid_0.all;
    use work.DataValid_17.all;
    use work.DataValid_38.all;
    use work.ShiftRegister_16.all;
    use work.DownCounter_0.all;
    use work.MovingAverage_2.all;
    use work.ShiftRegister_0.all;
    use work.MovingAverage_0.all;
    use work.ShiftRegister_18.all;
    use work.DCRemoval_1.all;
    use work.Windower_0.all;
    use work.ShiftRegister_15.all;
    use work.DownCounter_14.all;
    use work.StageR2SDF_12.all;
    use work.ShiftRegister_3.all;
    use work.DownCounter_2.all;
    use work.StageR2SDF_0.all;
    use work.ShiftRegister_4.all;
    use work.DownCounter_3.all;
    use work.StageR2SDF_1.all;
    use work.ShiftRegister_5.all;
    use work.DownCounter_4.all;
    use work.StageR2SDF_2.all;
    use work.DownCounter_5.all;
    use work.StageR2SDF_3.all;
    use work.ShiftRegister_7.all;
    use work.DownCounter_6.all;
    use work.StageR2SDF_4.all;
    use work.ShiftRegister_8.all;
    use work.DownCounter_7.all;
    use work.StageR2SDF_5.all;
    use work.ShiftRegister_9.all;
    use work.DownCounter_8.all;
    use work.StageR2SDF_6.all;
    use work.ShiftRegister_10.all;
    use work.DownCounter_9.all;
    use work.StageR2SDF_7.all;
    use work.ShiftRegister_11.all;
    use work.DownCounter_10.all;
    use work.StageR2SDF_8.all;
    use work.ShiftRegister_12.all;
    use work.DownCounter_11.all;
    use work.StageR2SDF_9.all;
    use work.ShiftRegister_13.all;
    use work.DownCounter_12.all;
    use work.StageR2SDF_10.all;
    use work.ShiftRegister_14.all;
    use work.StageR2SDF_11.all;
    use work.R2SDF_0.all;

-- Turns FFT result into power ~equalish to : abs(fft_result)
-- Note that this core consumes Complex samples but outputs Sfix samples.
-- TODO: Should output unsigned
package FFTPower_1 is
    type self_t is record
        \out\: DataValid_38.self_t;
    end record;
    type FFTPower_1_self_t_list_t is array (natural range <>) of FFTPower_1.self_t;

    type self_t_const is record
        \out\: DataValid_38.self_t_const;
    end record;
    type FFTPower_1_self_t_const_list_t_const is array (natural range <>) of FFTPower_1.self_t_const;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_17.self_t; ret_0:out DataValid_38.self_t);
    function FFTPower(\out\: DataValid_38.self_t) return self_t;
end package;

package body FFTPower_1 is
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_17.self_t; ret_0:out DataValid_38.self_t) is

        variable conjugate: complex_t(-7 downto -42);
    begin
        if not inp.valid then
            ret_0 := DataValid(self.\out\.data, valid=>False);
            return;

        end if;
        conjugate := resize(resize(Complex(get_real(inp.data), -get_imag(inp.data)), size_res=>inp.data, overflow_style=>fixed_wrap, round_style=>fixed_truncate), -4, -21, fixed_wrap, fixed_truncate);
        self_next.\out\.data := resize(get_real((conjugate * inp.data)), -7, -42, fixed_wrap, fixed_truncate);
        self_next.\out\.valid := inp.valid;
        ret_0 := self.\out\;
        return;
    end procedure;

    function FFTPower(\out\: DataValid_38.self_t) return self_t is
        -- constructor
        variable self: self_t;
    begin
        self.\out\ := \out\;
        return self;
    end function;
end package body;
