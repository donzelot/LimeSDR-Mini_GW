-- generated by pyha 0.0.11
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataValid_0.all;
    use work.DataValid_1.all;
    use work.DataValid_2.all;
    use work.DataValid_3.all;
    use work.DataValid_4.all;
    use work.ShiftRegister_5.all;
    use work.DownCounter_6.all;
    use work.MovingAverage_7.all;
    use work.ShiftRegister_8.all;
    use work.MovingAverage_9.all;
    use work.ShiftRegister_10.all;
    use work.DCRemoval_11.all;
    use work.Windower_12.all;
    use work.ShiftRegister_13.all;
    use work.DownCounter_14.all;
    use work.StageR2SDF_15.all;
    use work.ShiftRegister_16.all;
    use work.DownCounter_17.all;
    use work.StageR2SDF_18.all;
    use work.ShiftRegister_19.all;
    use work.DownCounter_20.all;
    use work.StageR2SDF_21.all;
    use work.ShiftRegister_22.all;
    use work.DownCounter_23.all;
    use work.StageR2SDF_24.all;
    use work.ShiftRegister_25.all;
    use work.DownCounter_26.all;
    use work.StageR2SDF_27.all;
    use work.ShiftRegister_28.all;
    use work.DownCounter_29.all;
    use work.StageR2SDF_30.all;
    use work.ShiftRegister_31.all;
    use work.DownCounter_32.all;
    use work.StageR2SDF_33.all;
    use work.ShiftRegister_34.all;
    use work.DownCounter_35.all;
    use work.StageR2SDF_36.all;
    use work.ShiftRegister_37.all;
    use work.StageR2SDF_38.all;
    use work.R2SDF_39.all;
    use work.FFTPower_40.all;
    use work.RAM_41.all;
    use work.DownCounter_42.all;

-- Bitreversal, FFTShift and AveragePooling
-- ----------------------------------------
-- Fixes bitreversal, performs fftshift and applies average pooling, implemented with 2 BRAM blocks.
-- Internal accumulator may be saturated.
-- Args:
-- fft_size:
-- avg_freq_axis: Pooling in frequnecy domain, decimates the data rate and has major impact on resource usage.
-- Large decimations use LESS memory.
-- Example, if input is 1024 point fft and avg_freq_axis is 2, then output is 512 points.
-- avg_time_axis: Pooling in time domain, decimates the data rate.
-- TODO: this core should be unsigned...
package BitreversalFFTshiftAVGPool_43 is
    type self_t is record
        time_axis_counter: integer;
        state: boolean;
        ram: RAM_41.RAM_41_self_t_list_t(0 to 1);
        out_valid: boolean;
        control: integer;
        output: DataValid_2.self_t;
        final_counter: DownCounter_42.self_t;
        start_counter: DownCounter_42.self_t;
    end record;
    type BitreversalFFTshiftAVGPool_43_self_t_list_t is array (natural range <>) of BitreversalFFTshiftAVGPool_43.self_t;

    type self_t_const is record
        AVG_FREQ_AXIS: integer;
        AVG_TIME_AXIS: integer;
        ACCUMULATION_BITS: integer;
        FFT_SIZE: integer;
        LUT: Typedefs.integer_list_t(0 to 511);
        ram: RAM_41.RAM_41_self_t_const_list_t_const(0 to 1);
        output: DataValid_2.self_t_const;
        final_counter: DownCounter_42.self_t_const;
        start_counter: DownCounter_42.self_t_const;
    end record;
    type BitreversalFFTshiftAVGPool_43_self_t_const_list_t_const is array (natural range <>) of BitreversalFFTshiftAVGPool_43.self_t_const;

    procedure work_ram(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; data: sfixed(1 downto -34); write_ram: integer; read_ram: integer);
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; input: DataValid_4.self_t; ret_0:out DataValid_2.self_t);
    function BitreversalFFTshiftAVGPool(time_axis_counter: integer; state: boolean; ram: RAM_41.RAM_41_self_t_list_t(0 to 1); out_valid: boolean; control: integer; output: DataValid_2.self_t; final_counter: DownCounter_42.self_t; start_counter: DownCounter_42.self_t) return self_t;
end package;

package body BitreversalFFTshiftAVGPool_43 is
    procedure work_ram(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; data: sfixed(1 downto -34); write_ram: integer; read_ram: integer) is

        variable write_index: integer;
        variable write_index_future: integer;
        variable read: sfixed(1 downto -34);
        variable new_value: sfixed(1 downto -34);
        variable \_\: sfixed(1 downto -34);
        variable pyha_ret_0: sfixed(1 downto -34);
        variable pyha_ret_1: sfixed(1 downto -34);
    begin
        -- READ-MODIFY-WRITE
        write_index := self_const.LUT(self.control);
        write_index_future := self_const.LUT((self.control + 1) mod self_const.FFT_SIZE);
        RAM_41.delayed_read(self.ram(write_ram), self_next.ram(write_ram), self_const.ram(write_ram), write_index_future, pyha_ret_0);
        read := resize(pyha_ret_0, 1, -34, fixed_saturate, fixed_truncate);
        new_value := resize(resize(read + data, size_res=>data, overflow_style=>fixed_saturate, round_style=>fixed_truncate), 1, -34, fixed_saturate, fixed_truncate);
        RAM_41.delayed_write(self.ram(write_ram), self_next.ram(write_ram), self_const.ram(write_ram), write_index, new_value);

        -- output stage
        self_next.out_valid := False;
        if self.control < self_const.FFT_SIZE / self_const.AVG_FREQ_AXIS and self.time_axis_counter = self_const.AVG_TIME_AXIS then
            RAM_41.delayed_read(self.ram(read_ram), self_next.ram(read_ram), self_const.ram(read_ram), self.control, pyha_ret_1);
            \_\ := resize(pyha_ret_1, 1, -34, fixed_saturate, fixed_truncate);
            self_next.out_valid := True;

            -- clear memory
            RAM_41.delayed_write(self.ram(read_ram), self_next.ram(read_ram), self_const.ram(read_ram), self.control, Sfix(0.0, size_res=>data, overflow_style=>fixed_wrap, round_style=>fixed_truncate));

        end if;
    end procedure;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; input: DataValid_4.self_t; ret_0:out DataValid_2.self_t) is
    -- Args:
    -- input (DataValid): 36 bits, type not restricted
    -- Returns:
    -- DataValid: Output type shifted right by the bit-growth.
        variable read: sfixed(1 downto -34);
        variable next_counter: integer;
        variable pyha_ret_2: sfixed(1 downto -34);
        variable pyha_ret_3: sfixed(1 downto -34);
        variable pyha_ret_4: boolean;
    begin
        if not input.valid then
            ret_0 := DataValid(self.output.data, valid=>False);
            return;

        end if;
        self_next.control := (self.control + 1) mod self_const.FFT_SIZE;
        if self.state then
            work_ram(self, self_next, self_const, input.data, 0, 1);
            RAM_41.get_readregister(self.ram(1), self_next.ram(1), self_const.ram(1), pyha_ret_2);
            read := resize(pyha_ret_2, 1, -34, fixed_wrap, fixed_truncate);
        else
            work_ram(self, self_next, self_const, input.data, 1, 0);
            RAM_41.get_readregister(self.ram(0), self_next.ram(0), self_const.ram(0), pyha_ret_3);
            read := resize(pyha_ret_3, 1, -34, fixed_wrap, fixed_truncate);

        end if;
        if self.control >= self_const.FFT_SIZE - 1 then
            next_counter := self.time_axis_counter - 1;
            if next_counter = 0 then
                next_counter := self_const.AVG_TIME_AXIS;
                self_next.state := not self.state;

            end if;
            self_next.time_axis_counter := next_counter;

        end if;
        self_next.output.data := resize(scalb(read, -self_const.ACCUMULATION_BITS), -7, -42, fixed_wrap, fixed_truncate);
        DownCounter_42.tick(self.start_counter, self_next.start_counter, self_const.start_counter);
        DownCounter_42.is_over(self.start_counter, self_next.start_counter, self_const.start_counter, pyha_ret_4);
        self_next.output.valid := pyha_ret_4 and self.out_valid;
        ret_0 := self.output;
        return;
    end procedure;

    function BitreversalFFTshiftAVGPool(time_axis_counter: integer; state: boolean; ram: RAM_41.RAM_41_self_t_list_t(0 to 1); out_valid: boolean; control: integer; output: DataValid_2.self_t; final_counter: DownCounter_42.self_t; start_counter: DownCounter_42.self_t) return self_t is
        -- constructor
        variable self: self_t;
    begin
        self.time_axis_counter := time_axis_counter;
        self.state := state;
        self.ram := ram;
        self.out_valid := out_valid;
        self.control := control;
        self.output := output;
        self.final_counter := final_counter;
        self.start_counter := start_counter;
        return self;
    end function;
end package body;
