-- generated by pyha 0.0.10
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataValid_27.all;
    use work.DataValid_26.all;
    use work.DataValid_25.all;
    use work.DataValid_0.all;
    use work.DataValid_23.all;
    use work.DataValid_24.all;
    use work.ShiftRegister_5.all;
    use work.DownCounter_0.all;
    use work.MovingAverage_2.all;
    use work.ShiftRegister_0.all;
    use work.MovingAverage_0.all;
    use work.ShiftRegister_7.all;
    use work.DCRemoval_1.all;
    use work.Windower_0.all;
    use work.ShiftRegister_20.all;
    use work.DownCounter_18.all;
    use work.StageR2SDF_13.all;
    use work.ShiftRegister_3.all;
    use work.DownCounter_2.all;
    use work.StageR2SDF_0.all;
    use work.ShiftRegister_4.all;
    use work.DownCounter_3.all;
    use work.StageR2SDF_2.all;
    use work.DownCounter_8.all;
    use work.StageR2SDF_3.all;
    use work.ShiftRegister_11.all;
    use work.DownCounter_9.all;
    use work.StageR2SDF_4.all;
    use work.ShiftRegister_12.all;
    use work.DownCounter_10.all;
    use work.StageR2SDF_5.all;
    use work.ShiftRegister_13.all;
    use work.DownCounter_11.all;
    use work.StageR2SDF_6.all;
    use work.ShiftRegister_14.all;
    use work.DownCounter_12.all;
    use work.StageR2SDF_7.all;
    use work.ShiftRegister_15.all;
    use work.DownCounter_13.all;
    use work.StageR2SDF_8.all;
    use work.ShiftRegister_16.all;
    use work.DownCounter_14.all;
    use work.StageR2SDF_9.all;
    use work.ShiftRegister_17.all;
    use work.DownCounter_15.all;
    use work.StageR2SDF_10.all;
    use work.ShiftRegister_18.all;
    use work.DownCounter_16.all;
    use work.StageR2SDF_11.all;
    use work.ShiftRegister_19.all;
    use work.StageR2SDF_12.all;
    use work.R2SDF_0.all;
    use work.FFTPower_0.all;
    use work.RAM_0.all;
    use work.DownCounter_20.all;

-- Performs bitreversal, fftshift and average pooling by using 2 BRAM blocks.
-- TODO: this core should be unsigned...
package BitreversalFFTshiftAVGPool_0 is
    type self_t is record
        time_axis_counter: integer;
        state: boolean;
        ram: RAM_0.RAM_0_self_t_list_t(0 to 1);
        out_valid: boolean;
        control: integer;
        \out\: DataValid_25.self_t;
        final_counter: DownCounter_9.self_t;
        start_counter: DownCounter_20.self_t;
    end record;
    type BitreversalFFTshiftAVGPool_0_self_t_list_t is array (natural range <>) of BitreversalFFTshiftAVGPool_0.self_t;

    type self_t_const is record
        AVG_FREQ_AXIS: integer;
        AVG_TIME_AXIS: integer;
        ACCUMULATION_BITS: integer;
        FFT_SIZE: integer;
        LUT: Typedefs.integer_list_t(0 to 8191);
        ram: RAM_0.RAM_0_self_t_const_list_t_const(0 to 1);
        \out\: DataValid_25.self_t_const;
        final_counter: DownCounter_9.self_t_const;
        start_counter: DownCounter_20.self_t_const;
    end record;
    type BitreversalFFTshiftAVGPool_0_self_t_const_list_t_const is array (natural range <>) of BitreversalFFTshiftAVGPool_0.self_t_const;

    procedure work_ram(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; data: sfixed(-5 downto -40); write_ram: integer; read_ram: integer);
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_24.self_t; ret_0:out DataValid_25.self_t);
    function BitreversalFFTshiftAVGPool(time_axis_counter: integer; state: boolean; ram: RAM_0.RAM_0_self_t_list_t(0 to 1); out_valid: boolean; control: integer; \out\: DataValid_25.self_t; final_counter: DownCounter_9.self_t; start_counter: DownCounter_20.self_t) return self_t;
end package;

package body BitreversalFFTshiftAVGPool_0 is
    procedure work_ram(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; data: sfixed(-5 downto -40); write_ram: integer; read_ram: integer) is

        variable write_index: integer;
        variable write_index_future: integer;
        variable read: sfixed(-5 downto -40);
        variable new_value: sfixed(-5 downto -40);
        variable \_\: sfixed(-5 downto -40);
        variable pyha_ret_0: sfixed(-5 downto -40);
        variable pyha_ret_1: sfixed(-5 downto -40);
    begin
        -- READ-MODIFY-WRITE
        write_index := self_const.LUT(self.control);
        write_index_future := self_const.LUT((self.control + 1) mod self_const.FFT_SIZE);
        RAM_0.delayed_read(self.ram(write_ram), self_next.ram(write_ram), self_const.ram(write_ram), write_index_future, pyha_ret_0);
        read := resize(pyha_ret_0, -5, -40, fixed_saturate, fixed_truncate);
        new_value := resize(resize(read + data, size_res=>data, overflow_style=>fixed_saturate, round_style=>fixed_truncate), -5, -40, fixed_saturate, fixed_truncate);
        RAM_0.delayed_write(self.ram(write_ram), self_next.ram(write_ram), self_const.ram(write_ram), write_index, new_value);

        -- output stage
        self_next.out_valid := False;
        if self.control < self_const.FFT_SIZE / self_const.AVG_FREQ_AXIS and self.time_axis_counter = self_const.AVG_TIME_AXIS then
            RAM_0.delayed_read(self.ram(read_ram), self_next.ram(read_ram), self_const.ram(read_ram), self.control, pyha_ret_1);
            \_\ := resize(pyha_ret_1, -5, -40, fixed_saturate, fixed_truncate);
            self_next.out_valid := True;

            -- clear memory
            RAM_0.delayed_write(self.ram(read_ram), self_next.ram(read_ram), self_const.ram(read_ram), self.control, Sfix(0.0, size_res=>data, overflow_style=>fixed_wrap, round_style=>fixed_truncate));

        end if;
    end procedure;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_24.self_t; ret_0:out DataValid_25.self_t) is

        variable read: sfixed(-5 downto -40);
        variable next_counter: integer;
        variable pyha_ret_2: sfixed(-5 downto -40);
        variable pyha_ret_3: sfixed(-5 downto -40);
        variable pyha_ret_4: boolean;
    begin
        if not inp.valid then
            ret_0 := DataValid(self.\out\.data, valid=>False);
            return;

        end if;
        self_next.control := (self.control + 1) mod self_const.FFT_SIZE;
        if self.state then
            work_ram(self, self_next, self_const, inp.data, 0, 1);
            RAM_0.get_readregister(self.ram(1), self_next.ram(1), self_const.ram(1), pyha_ret_2);
            read := resize(pyha_ret_2, -5, -40, fixed_wrap, fixed_truncate);
        else
            work_ram(self, self_next, self_const, inp.data, 1, 0);
            RAM_0.get_readregister(self.ram(0), self_next.ram(0), self_const.ram(0), pyha_ret_3);
            read := resize(pyha_ret_3, -5, -40, fixed_wrap, fixed_truncate);

        end if;
        if self.control >= self_const.FFT_SIZE - 1 then
            next_counter := self.time_axis_counter - 1;
            if next_counter = 0 then
                next_counter := self_const.AVG_TIME_AXIS;
                self_next.state := not self.state;

            end if;
            self_next.time_axis_counter := next_counter;

        end if;
        self_next.\out\.data := resize(scalb(read, -self_const.ACCUMULATION_BITS), -12, -47, fixed_wrap, fixed_truncate);
        DownCounter_20.tick(self.start_counter, self_next.start_counter, self_const.start_counter);
        DownCounter_20.is_over(self.start_counter, self_next.start_counter, self_const.start_counter, pyha_ret_4);
        self_next.\out\.valid := pyha_ret_4 and self.out_valid;
        ret_0 := self.\out\;
        return;
    end procedure;

    function BitreversalFFTshiftAVGPool(time_axis_counter: integer; state: boolean; ram: RAM_0.RAM_0_self_t_list_t(0 to 1); out_valid: boolean; control: integer; \out\: DataValid_25.self_t; final_counter: DownCounter_9.self_t; start_counter: DownCounter_20.self_t) return self_t is
        -- constructor
        variable self: self_t;
    begin
        self.time_axis_counter := time_axis_counter;
        self.state := state;
        self.ram := ram;
        self.out_valid := out_valid;
        self.control := control;
        self.\out\ := \out\;
        self.final_counter := final_counter;
        self.start_counter := start_counter;
        return self;
    end function;
end package body;
