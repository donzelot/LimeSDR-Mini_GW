-- generated by pyha 0.0.10
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataValid_21.all;
    use work.DataValid_20.all;
    use work.DataValid_19.all;
    use work.DataValid_0.all;
    use work.DataValid_17.all;
    use work.DataValid_18.all;
    use work.ShiftRegister_0.all;
    use work.DownCounter_0.all;
    use work.MovingAverage_0.all;
    use work.ShiftRegister_1.all;
    use work.MovingAverage_1.all;
    use work.ShiftRegister_2.all;

-- Filter out DC component, based on: https://www.dsprelated.com/showarticle/58.php
package DCRemoval_0 is
    type self_t is record
        averages: MovingAverage_0.MovingAverage_0_self_t_list_t(0 to 1);
        averages_0: MovingAverage_0.self_t;
        averages_1: MovingAverage_1.self_t;
        delayed_input: ShiftRegister_2.self_t;
        \out\: DataValid_0.self_t;
    end record;
    type DCRemoval_0_self_t_list_t is array (natural range <>) of DCRemoval_0.self_t;

    type self_t_const is record
        WINDOW_LEN: integer;
        averages: MovingAverage_0.MovingAverage_0_self_t_const_list_t_const(0 to 1);
        averages_0: MovingAverage_0.self_t_const;
        averages_1: MovingAverage_1.self_t_const;
        delayed_input: ShiftRegister_2.self_t_const;
        \out\: DataValid_0.self_t_const;
    end record;
    type DCRemoval_0_self_t_const_list_t_const is array (natural range <>) of DCRemoval_0.self_t_const;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_21.self_t; ret_0:out DataValid_0.self_t);
    function DCRemoval(averages_0: MovingAverage_0.self_t;averages_1: MovingAverage_1.self_t; delayed_input: ShiftRegister_2.self_t; \out\: DataValid_0.self_t) return self_t;
end package;

package body DCRemoval_0 is
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataValid_21.self_t; ret_0:out DataValid_0.self_t) is

        variable avg_out: DataValid_0.self_t;
        variable pyha_ret_0: DataValid_0.self_t;
        variable pyha_ret_1: DataValid_0.self_t;
        variable pyha_ret_2: complex_t(1 downto -22);
        variable pyha_ret_3: complex_t(1 downto -22);
    begin
        MovingAverage_0.main(self.averages_0, self_next.averages_0, self_const.averages_0, inp, pyha_ret_0);
        MovingAverage_1.main(self.averages_1, self_next.averages_1, self_const.averages_1, pyha_ret_0, pyha_ret_1);
        avg_out := pyha_ret_1;

        if not avg_out.valid then
            ret_0 := DataValid(self.\out\.data, valid=>False);
            return;

            -- delay input -> use averager[0] delay to save alot of RAM
        end if;
        ShiftRegister_0.peek(self.averages_0.shr, self_next.averages_0.shr, self_const.averages_0.shr, pyha_ret_2);
        ShiftRegister_2.push_next(self.delayed_input, self_next.delayed_input, self_const.delayed_input, pyha_ret_2);
        ShiftRegister_2.peek(self.delayed_input, self_next.delayed_input, self_const.delayed_input, pyha_ret_3);
        self_next.\out\.data := resize(pyha_ret_3 - avg_out.data, 0, -17, fixed_wrap, fixed_truncate);
        self_next.\out\.valid := True;
        ret_0 := self.\out\;
        return;
    end procedure;

    function DCRemoval(averages_0: MovingAverage_0.self_t;averages_1: MovingAverage_1.self_t; delayed_input: ShiftRegister_2.self_t; \out\: DataValid_0.self_t) return self_t is
        -- constructor
        variable self: self_t;
    begin
        self.averages_0 := averages_0;
        self.averages_1 := averages_1;
        self.delayed_input := delayed_input;
        self.\out\ := \out\;
        return self;
    end function;
end package body;
